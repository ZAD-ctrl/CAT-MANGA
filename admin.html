// ----------------------------------------------------------------
        // ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø©
        const GITHUB_USERNAME = 'zad-ctrl'; // ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
        const REPO_NAME = 'CAT-MANGA'; // ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
        const BASE_API_URL = `https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/contents/`;
        const DATA_FILE_PATH = 'data/manga_list.json';

        function updateStatus(message, color = '#d29922') {
            document.getElementById('status_message').innerText = `Ø­Ø§Ù„Ø© Ø§Ù„Ø±ÙØ¹: ${message}`;
            document.getElementById('status_message').style.color = color;
        }

        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¥Ù„Ù‰ Base64
        function getBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
        }

        // Ø¬Ù„Ø¨ Ù…Ø­ØªÙˆÙ‰ Ù…Ù„Ù Ù…Ø¹ÙŠÙ† (Ù…Ø«Ù„ Ù…Ù„Ù JSON)
        async function fetchFileContent(filePath, patToken) {
            const url = BASE_API_URL + filePath;
            const response = await fetch(url, {
                headers: {
                    'Authorization': `token ${patToken}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });

            if (response.status === 404) {
                return null; // Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ (ÙˆÙ‡Ø°Ø§ Ø·Ø¨ÙŠØ¹ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£ÙˆÙ„ Ø±ÙØ¹)
            }
            if (!response.ok) {
                throw new Error(`ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù„Ù ${filePath}: ${response.statusText}`);
            }

            const data = await response.json();
            const content = atob(data.content); // ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ù† Base64
            
            return {
                sha: data.sha,
                content: content
            };
        }

        // ØªØ­Ø¯ÙŠØ« Ù…Ø­ØªÙˆÙ‰ Ù…Ù„Ù JSON Ø¹Ù„Ù‰ GitHub
        async function updateFile(filePath, content, message, sha, patToken) {
            const url = BASE_API_URL + filePath;
            const contentBase64 = btoa(unescape(encodeURIComponent(content))); // ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¥Ù„Ù‰ Base64
            
            const payload = {
                message: message,
                content: contentBase64,
                sha: sha 
            };

            const response = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${patToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù ${filePath}: ${errorData.message}`);
            }
            return response.json();
        }

        // ----------------------------------------------------------------
        // ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø±ÙØ¹ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (uploadStart)
        async function uploadStart() {
            const patToken = document.getElementById('pat_token').value.trim();
            const mangaId = document.getElementById('manga_id').value.trim();
            const chapterNum = parseInt(document.getElementById('chapter_number').value);
            const chapterTitle = document.getElementById('chapter_title').value.trim();
            const imagesInput = document.getElementById('chapter_images');
            const files = imagesInput.files;

            if (!patToken || !mangaId || isNaN(chapterNum) || !chapterTitle || files.length === 0) {
                updateStatus('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ¹Ø¨Ø¦Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙˆØ§Ø®ØªÙŠØ§Ø± Ø§Ù„ØµÙˆØ±.', 'red');
                return;
            }

            updateStatus('Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±ÙØ¹...');

            try {
                // 1. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù„Ù manga_list.json
                const jsonFileData = await fetchFileContent(DATA_FILE_PATH, patToken);
                let mangaData;
                let jsonSha = null;

                if (jsonFileData) {
                    mangaData = JSON.parse(jsonFileData.content);
                    jsonSha = jsonFileData.sha;
                } else {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ØŒ Ø¥Ù†Ø´Ø§Ø¡ Ù‡ÙŠÙƒÙ„ Ø¬Ø¯ÙŠØ¯
                    mangaData = { manga: [] };
                }

                // 2. ØªØ­Ø¯ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø±ÙØ¹
                const chapterPath = `uploads/${mangaId}/c${chapterNum}`;
                const pagesPaths = [];

                // 3. Ø±ÙØ¹ Ø§Ù„ØµÙˆØ± Ø¥Ù„Ù‰ GitHub
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const pageFileName = `page${i + 1}.${file.name.split('.').pop()}`;
                    const fullImagePath = `${chapterPath}/${pageFileName}`;
                    
                    updateStatus(`Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© ${i + 1} Ù…Ù† ${files.length} (${pageFileName})...`);

                    const contentBase64 = await getBase64(file);
                    
                    // Ù„Ø§ Ù†Ø­ØªØ§Ø¬ Ù„Ù„Ù€ SHA Ù‡Ù†Ø§ Ù„Ø£Ù†Ù†Ø§ Ù†Ø±ÙØ¹ Ù…Ù„ÙØ§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹ ÙÙŠ ÙƒÙ„ Ù…Ø±Ø©
                    await updateFile(
                        fullImagePath, 
                        atob(contentBase64), // ÙŠØ¬Ø¨ Ø£Ù† Ù†Ù…Ø±Ø± Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ØºÙŠØ± Ø§Ù„Ù…Ø´ÙØ± Ù„ÙƒÙŠ ÙŠØªÙ… ØªØ´ÙÙŠØ±Ù‡ Ø¯Ø§Ø®Ù„ Ø¯Ø§Ù„Ø© updateFile
                        `[ADD] Upload ${mangaId} Chapter ${chapterNum} Page ${i + 1}`,
                        undefined, 
                        patToken
                    );
                    pagesPaths.push(fullImagePath);
                }

                // 4. ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù manga_list.json
                updateStatus('Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...');

                let mangaIndex = mangaData.manga.findIndex(m => m.id === mangaId);

                const newChapter = {
                    chapter_number: chapterNum,
                    title: chapterTitle,
                    pages: pagesPaths
                };
                
                if (mangaIndex === -1) {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø§Ù†Ù‡ÙˆØ§ Ø¬Ø¯ÙŠØ¯Ø©
                    mangaData.manga.push({
                        id: mangaId,
                        title: chapterTitle.split('-')[0].trim(), // Ø¹Ù†ÙˆØ§Ù† Ø£Ø³Ø§Ø³ÙŠ Ø¨Ø³ÙŠØ·
                        cover_image: `uploads/${mangaId}/cover.jpg`, // Ù…Ø³Ø§Ø± Ø§ÙØªØ±Ø§Ø¶ÙŠ
                        chapters: [newChapter]
                    });
                } else {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø§Ù†Ù‡ÙˆØ§ Ù…ÙˆØ¬ÙˆØ¯Ø©
                    let chapterIndex = mangaData.manga[mangaIndex].chapters.findIndex(c => c.chapter_number === chapterNum);
                    
                    if (chapterIndex !== -1) {
                        // ØªØ­Ø¯ÙŠØ« ÙØµÙ„ Ù…ÙˆØ¬ÙˆØ¯
                        mangaData.manga[mangaIndex].chapters[chapterIndex] = newChapter;
                    } else {
                        // Ø¥Ø¶Ø§ÙØ© ÙØµÙ„ Ø¬Ø¯ÙŠØ¯
                        mangaData.manga[mangaIndex].chapters.push(newChapter);
                        // ÙØ±Ø² Ø§Ù„ÙØµÙˆÙ„ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„ØªÙ†Ø§Ø²Ù„ÙŠ ÙÙŠ index.html
                        mangaData.manga[mangaIndex].chapters.sort((a, b) => b.chapter_number - a.chapter_number);
                    }
                }

                // ØªÙ†ÙÙŠØ° ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù JSON
                await updateFile(
                    DATA_FILE_PATH,
                    JSON.stringify(mangaData, null, 2),
                    `[UPDATE] Added/Updated ${mangaId} Chapter ${chapterNum}`,
                    jsonSha,
                    patToken
                );

                updateStatus('ØªÙ… Ø§Ù„Ø±ÙØ¹ ÙˆØ§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ù†Ø¬Ø§Ø­! ğŸ‰', 'lime');
                
            } catch (error) {
                updateStatus(`Ø®Ø·Ø£ ÙØ§Ø¯Ø­: ${error.message}`, 'red');
                console.error('Upload Error:', error);
            }
        }
